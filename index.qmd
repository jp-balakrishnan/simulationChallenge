---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# üé≤ Simulation Challenge - Starter Template

:::: {.callout-important}
## üìã What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## ‚ö†Ô∏è AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

After each coin flip:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You flip the coin 35 times. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1‚Äì4: required and can earn up to 90% of the grade.
- Sections 5‚Äì6: optional; strong, well-supported work here can bring your score up to 100%.
::::

### 1) Expected Value After 1 Flip

What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

```{python}
#| label: q1-expected-value-py
#| echo: false

# Compute EV after one flip in Python
# Show calculation and brief explanation
EV = 0.5 * 1.5 * 30000 + 0.5 * 0.6 * 30000
print(f"Expected value after one flip: ${EV:,.2f}")
print(f"Gain in expected value: ${EV - 30000:,.2f} ({((EV - 30000) / 30000) * 100:.2f}%)")
print(f"\nThe expected value of your account balance after one flip is ${EV:,.2f}.")
print("This is less than $30,000, so you should not buy-in to the game based on expected value alone.")

```

### 2) Single Simulation Over Time (Narrative + Plot)

Following visualize and narrative explains what happens to account balance over the course of one run. 

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance"

# Simulate one path from $30,000 over N periods
# - Make a matplotlib (OO) time-series
# - Set seed for reproducibility

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

# Set seed for reproducibility
np.random.seed(58)

# Define the parameters
initial_balance = 30000
N = 35  # Number of coin flips

# Initialize arrays
coin_flips = np.arange(0, N + 1)  # From 0 to N coin flips (inclusive)
balances = np.zeros(N + 1)
balances[0] = initial_balance

# Simulate the balance over coin flips
for t in range(1, N + 1):
    if np.random.random() < 0.5:  # Heads
        balances[t] = balances[t-1] * 1.5
    else:  # Tails
        balances[t] = balances[t-1] * 0.6

# Create DataFrame
df = pd.DataFrame({'Coin_Flip': coin_flips, 'Balance': balances})
df.set_index('Coin_Flip', inplace=True)

print(f"Starting balance: ${initial_balance:,.2f}")
print(f"Final balance after {N} coin flips: ${balances[-1]:,.2f}")
print(f"Change: ${balances[-1] - initial_balance:,.2f} ({((balances[-1] / initial_balance) - 1) * 100:.2f}%)")

# Enhanced plot with stock market style and detailed styling
fig, ax = plt.subplots(figsize=(8, 5))
# fig.patch.set_facecolor('#ffffff')

# # Set background color
# ax.set_facecolor('#fafbfc')

# Plot line segments colored by gain/loss (stock market style)
for i in range(len(df.index) - 1):
    if balances[i+1] >= balances[i]:  # Gain (green)
        color = '#27ae60'  # Darker green for gains
        linewidth = 2.8
    else:  # Loss (red)
        color = '#c0392b'  # Darker red for losses
        linewidth = 2.8
    
    ax.plot(df.index[i:i+2], balances[i:i+2], 
            color=color, linewidth=linewidth, solid_capstyle='round', 
            zorder=3, alpha=0.9)

# Add markers at start and end points
final_balance = balances[-1]  # Define early for use in labels
ax.scatter(df.index[0], balances[0], color='#3498db', s=150, 
          zorder=5, marker='o', edgecolors='white', linewidths=2, 
          alpha=0.9)
ax.scatter(df.index[-1], balances[-1], 
          color='#2ecc71' if balances[-1] >= initial_balance else '#e74c3c', 
          s=150, zorder=5, marker='s', edgecolors='white', linewidths=2, 
          alpha=0.9)

# Add balance amount labels for each marker
# Note: final_balance already defined above

# Initial balance label
ax.annotate(f'${balances[0]:,.0f}', 
            xy=(df.index[0], balances[0]), 
            xytext=(df.index[0], balances[0] + (balances.max() - balances.min()) * 0.08),
            ha='center', va='bottom', fontsize=10, fontweight='bold',
            color='#3498db',
            bbox=dict(boxstyle='round,pad=0.5', facecolor='white', 
                     edgecolor='#3498db', alpha=0.9, linewidth=1.5),
            zorder=6, arrowprops=dict(arrowstyle='->', color='#3498db', lw=1.5))

# Final balance label
ax.annotate(f'${final_balance:,.0f}', 
            xy=(df.index[-1], final_balance), 
            xytext=(df.index[-1], final_balance + (balances.max() - balances.min()) * 0.08),
            ha='center', va='bottom', fontsize=10, fontweight='bold',
            color='#2ecc71' if final_balance >= initial_balance else '#e74c3c',
            bbox=dict(boxstyle='round,pad=0.5', facecolor='white', 
                     edgecolor='#2ecc71' if final_balance >= initial_balance else '#e74c3c', 
                     alpha=0.9, linewidth=1.5),
            zorder=6, arrowprops=dict(arrowstyle='->', 
                                     color='#2ecc71' if final_balance >= initial_balance else '#e74c3c', 
                                     lw=1.5))

# Enhanced formatting
ax.set_xlabel('Coin Flip Number', fontsize=13, fontweight='bold', color='#2c3e50')
ax.set_ylabel('Account Balance ($)', fontsize=13, fontweight='bold', color='#2c3e50')
ax.set_title('Account Balance Over Coin Flips', fontsize=16, fontweight='bold')

# Enhanced legend
legend = ax.legend(loc='upper left', framealpha=0.95, fontsize=10.5, 
                  edgecolor='#bdc3c7', fancybox=True, shadow=True)
legend.get_frame().set_facecolor('#ffffff')


# Note: final_balance already defined above
final_flip = df.index[-1]
if final_balance >= initial_balance:
    annotation_color = '#27ae60'
else:
    annotation_color = '#c0392b'

# Add subtle watermark-style label
ax.text(0.99, 0.01, 'Investment Simulation Analysis', 
        transform=ax.transAxes, fontsize=9, 
        color='#bdc3c7', ha='right', va='bottom', 
        style='italic', alpha=0.6)

plt.tight_layout()
plt.show()

# Calculate key statistics for narrative
max_balance = balances.max()
min_balance = balances.min()
max_flip = int(np.argmax(balances))
min_flip = int(np.argmin(balances))
num_gains = int(np.sum(np.diff(balances) > 0))
num_losses = int(np.sum(np.diff(balances) < 0))
return_pct = ((final_balance / initial_balance) - 1) * 100
loss_amount = initial_balance - final_balance
```



```{python}
#| echo: false
#| output: asis
# Generate narrative text in markdown format
outcome_assessment = "happy" if final_balance > initial_balance else ("unhappy" if final_balance < initial_balance else "neutral")

if outcome_assessment == "happy":
    assessment_text = "**‚úÖ OUTCOME ASSESSMENT: I am HAPPY with this outcome. Its not profitable all time and its risky investment **"
    reason_text = f"The investment grew from ${initial_balance:,.2f} to ${final_balance:,.2f}, representing a {return_pct:.2f}% return. This is a {return_pct:.2f}% profit on the initial investment. Despite the volatility shown in the graph (with gains and losses throughout), the final result shows a positive return, which meets the basic goal of earning more than what was initially invested."
elif outcome_assessment == "unhappy":
    assessment_text = "**‚ùå OUTCOME ASSESSMENT: I am NOT HAPPY with this outcome.**"
    reason_text = f"The investment decreased from ${initial_balance:,.2f} to ${final_balance:,.2f}, representing a {return_pct:.2f}% loss. This means I lost ${loss_amount:,.2f}. The simulation shows high volatility, with periods of gains followed by losses, but ultimately ending below the initial investment. This is a disappointing outcome as it represents a net loss rather than a gain."
else:
    assessment_text = "**‚ö™ OUTCOME ASSESSMENT: I am NEUTRAL about this outcome.**"
    reason_text = f"The investment ended exactly at ${initial_balance:,.2f}, representing no gain or loss. After {N} coin flips with significant volatility, breaking even is neither satisfying nor disappointing."

# Print the narrative as markdown
print(f"""Starting with ${initial_balance:,.2f}, the simulation ran through {N} coin flips. Out of {N} flips, {num_gains} resulted in gains (heads: +50%) and {num_losses} resulted in losses (tails: -40%).

**Key Moments:**
- Maximum balance: ${max_balance:,.2f} reached at coin flip {max_flip}
- Minimum balance: ${min_balance:,.2f} reached at coin flip {min_flip}
- Final balance: ${final_balance:,.2f} after {N} coin flips

{assessment_text}

{reason_text}

The simulation demonstrates the high volatility inherent in this investment game, with balance fluctuating dramatically between coin flips. The color-coded line shows alternating periods of gains (green) and losses (red), illustrating the risky nature of this strategy.""")
```


### 3) 100 Simulations: Distribution of Final Balances

Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

```{python}
#| label: q3-dist-100-py
#| echo: false

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import seaborn as sns
import pandas as pd
from IPython.display import Markdown

# Parameters
starting_balance = 30000
N = 35  # Number of coin flips
n_simulations = 100

# Run simulations
final_balances = []
np.random.seed(55)  # For reproducibility

for _ in range(n_simulations):
    balance = starting_balance
    flips = np.random.choice(['Heads', 'Tails'], size=N)
    for flip in flips:
        balance *= 1.5 if flip == 'Heads' else 0.6
    final_balances.append(balance)

# Create DataFrame
results_df = pd.DataFrame({
    'Simulation': range(1, n_simulations + 1),
    'Final Balance': final_balances
})
results_df['Final Balance'] = results_df['Final Balance'].round(2)

final_balances = np.array(final_balances)

# Compute statistics
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
std_balance = np.std(final_balances)
min_balance = np.min(final_balances)
max_balance = np.max(final_balances)

# Probability calculations
prob_above_buyin = np.mean(final_balances > starting_balance)
prob_double = np.mean(final_balances >= 2 * starting_balance)  # Outcomes that double your money
prob_break_even = np.mean(final_balances >= starting_balance)  # Break-even or better

# Create visualization
sns.set(style="whitegrid")
fig, ax = plt.subplots(figsize=(8, 5))

# Background shading
x_min = min(results_df['Final Balance'].min(), starting_balance * 0.5)
x_max = results_df['Final Balance'].max() * 1.1
ax.axvspan(x_min, starting_balance, color='red', alpha=0.1, label='Loss Zone')
ax.axvspan(starting_balance, x_max, color='green', alpha=0.1, label='Profit Zone')

# Histogram with log-scaled x-axis
sns.histplot(results_df['Final Balance'], bins=30, log_scale=(True, False),
             color='skyblue', edgecolor='black', ax=ax)

# Vertical line at $30,000
ax.axvline(x=starting_balance, color='red', linestyle='--', linewidth=2, label='Starting Balance ($30,000)')

# Format x-axis in dollar notation
ax.xaxis.set_major_formatter(ticker.StrMethodFormatter('${x:,.0f}'))

# Labels and title
plt.title('Distribution of Account Balances (100 Simulations)', fontsize=16, weight='bold')
plt.xlabel('Account Balance ($)', fontsize=12)
plt.ylabel('Frequency', fontsize=12)
plt.legend()
plt.tight_layout()
plt.show()

# Update below print statements as nicely formatted text using quarto
# Display the narrative as Quarto-formatted markdown
display(Markdown(f""" The following are the distribution analysis of the 100 simulations:

**DISTRIBUTION ANALYSIS**

Simulation Parameters:

* Initial investment: ${starting_balance:,}
* Number of coin flips: {N}
* Number of simulations: {n_simulations}

**Distribution Statistics:**

* Mean final balance: ${mean_balance:,.2f}
* Median final balance: ${median_balance:,.2f}
* Standard deviation: ${std_balance:,.2f}
* Minimum final balance: ${min_balance:,.2f}
* Maximum final balance: ${max_balance:,.2f}

**Probability of favorable outcomes:**

* P(final balance > ${starting_balance:,}): {prob_above_buyin:.1%} ({np.sum(final_balances > starting_balance)}/{n_simulations} simulations)
* P(final balance ‚â• ${2*starting_balance:,}): {prob_double:.1%} ({np.sum(final_balances >= 2*starting_balance)}/{n_simulations} simulations)
* P(final balance ‚â• ${starting_balance:,}): {prob_break_even:.1%} (break-even or better)

"""))


risk_assessment = ""
if prob_above_buyin < 0.5:
    risk_assessment = "Less than half of simulations result in profit - this is a HIGH RISK investment"
elif prob_above_buyin < 0.6:
    risk_assessment = "Slightly more than half result in profit - this is a MODERATE RISK investment"
else:
    risk_assessment = "More than half of simulations result in profit - but still risky due to volatility"

# Display the narrative as Quarto-formatted markdown
display(Markdown(f"""
After running {n_simulations} simulations of the investment game over {N} coin flips:

**1. DISTRIBUTION CHARACTERISTICS:**

* The distribution is highly skewed with a long right tail
* Mean balance (${mean_balance:,.2f}) is {'higher' if mean_balance > median_balance else 'lower'} than median (${median_balance:,.2f})
* This indicates extreme outcomes: some simulations result in very high balances, while others result in significant losses
* The wide range (${min_balance:,.2f} to ${max_balance:,.2f}) shows high variability

**2. PROBABILITY OF HAPPY OUTCOMES:**

* After investing ${starting_balance:,}, the probability of ending with **MORE** than your initial investment is {prob_above_buyin:.1%}
* This means in {np.sum(final_balances > starting_balance)} out of {n_simulations} simulations, you would be profitable
* The probability of at least DOUBLING your money is {prob_double:.1%}

**3. RISK ASSESSMENT:**

* {risk_assessment}
* The high standard deviation (${std_balance:,.2f}) indicates significant uncertainty
* You could lose as much as ${starting_balance - min_balance:,.2f} or gain as much as ${max_balance - starting_balance:,.2f}

**4. CONCLUSION:**
If you define 'happy outcomes' as finishing with more than your ${starting_balance:,} investment, the probability is {prob_above_buyin:.1%}
However, the extreme variability means outcomes are highly unpredictable
"""))
```

### 4) Probability Balance > $30,000 After 35 Coin Flips (Original Game)

Report the probability estimate and interpret its practical meaning.

```{python}
#| label: q4-prob-original-py
#| echo: false

# Print number of successes and total simulations
success_count = (results_df['Final Balance'] > starting_balance).sum()
simulations = len(results_df)
print(f"Number of successful simulations (Final Balance > $30,000): {success_count:.2f}")
print(f"Total number of simulations: {simulations}")
print(f"The probability of ending with more than $30,000 after 35 coin flips is {prob_above_buyin:.3f}")
print(f"This means that in {np.sum(final_balances > starting_balance)} out of {n_simulations} simulations, you would be profitable.")   
```

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 50% of  balance is gambled each round. Compare this to the original game. Which is riskier? Which has better upside?

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Comparison of original and modified strategy distributions (bet 50% each round)"

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import seaborn as sns

# Parameters (matching sections 3 and 4)
starting_balance = 30000
N = 35  # Number of coin flips
n_simulations = 100

# Run simulations for both strategies
np.random.seed(45)  # Same seed as section 3 for fair comparison

# Original strategy: full balance at risk
original_balances = []
for _ in range(n_simulations):
    balance = starting_balance
    for _ in range(N):
        flip = np.random.choice(['Heads', 'Tails'])
        balance = balance * 1.5 if flip == 'Heads' else balance * 0.6
    original_balances.append(balance)

# Modified strategy: only 50% of balance is gambled each round
# 50% is at risk, 50% is kept safe
def simulate_partial_risk():
    balance = starting_balance
    for _ in range(N):
        gamble = balance * 0.50  # 50% at risk
        safe = balance * 0.50    # 50% kept safe
        flip = np.random.choice(['Heads', 'Tails'])
        # Apply gain/loss only to the gambled portion
        gamble = gamble * 1.5 if flip == 'Heads' else gamble * 0.6
        balance = gamble + safe  # Combine gambled and safe portions
    return balance

# Run simulations for modified strategy
modified_balances = [simulate_partial_risk() for _ in range(n_simulations)]

# Create DataFrames for comparison
original_df = pd.DataFrame({
    'Simulation': range(1, n_simulations + 1),
    'Final Balance': np.round(original_balances, 2),
    'Strategy': 'Original'
})

modified_df = pd.DataFrame({
    'Simulation': range(1, n_simulations + 1),
    'Final Balance': np.round(modified_balances, 2),
    'Strategy': 'Modified'
})

combined_df = pd.concat([original_df, modified_df], ignore_index=True)

original_balances = np.array(original_balances)
modified_balances = np.array(modified_balances)

# Compute statistics for both strategies
orig_mean = np.mean(original_balances)
orig_median = np.median(original_balances)
orig_std = np.std(original_balances)
orig_prob_gain = np.mean(original_balances > starting_balance)
orig_min = np.min(original_balances)
orig_max = np.max(original_balances)

mod_mean = np.mean(modified_balances)
mod_median = np.median(modified_balances)
mod_std = np.std(modified_balances)
mod_prob_gain = np.mean(modified_balances > starting_balance)
mod_min = np.min(modified_balances)
mod_max = np.max(modified_balances)

# --- Plotting ---
sns.set(style="whitegrid")
fig, ax = plt.subplots(figsize=(8, 5))

# Background shading
x_min = min(min(original_df['Final Balance']), min(modified_df['Final Balance']), starting_balance * 0.5)
x_max = max(max(original_df['Final Balance']), max(modified_df['Final Balance'])) * 1.1
ax.axvspan(x_min, starting_balance, color='red', alpha=0.1, label='Loss Zone')
ax.axvspan(starting_balance, x_max, color='green', alpha=0.1, label='Profit Zone')

# Histograms
sns.histplot(original_df['Final Balance'], bins=30, log_scale=(True, False),
             color='skyblue', edgecolor='black', label='Full Risk Strategy (Original)', 
             ax=ax, alpha=0.6)
sns.histplot(modified_df['Final Balance'], bins=30, log_scale=(True, False),
             color='orange', edgecolor='black', label='Partial Risk Strategy (50% at Risk)', 
             ax=ax, alpha=0.6)

# Vertical line at $30,000
ax.axvline(x=starting_balance, color='red', linestyle='--', linewidth=2, 
           label=f'Starting Balance (${starting_balance:,})')

# Dollar formatting
ax.xaxis.set_major_formatter(ticker.StrMethodFormatter('${x:,.0f}'))

# Labels and legend
plt.title('Final Account Balance Distribution: Full vs Partial Risk Strategies', 
          fontsize=16, weight='bold')
plt.xlabel('Final Balance ($)', fontsize=12)
plt.ylabel('Frequency', fontsize=12)
plt.legend(loc='upper right', fontsize=10)
plt.tight_layout()
plt.show()

if orig_std > mod_std:
    risk_text = f"""
* The Original strategy is RISKIER (std dev: ${orig_std:,.2f} vs ${mod_std:,.2f})
* Higher volatility means more uncertainty"""
    
else:
    risk_text = f"""
* The Modified strategy is RISKIER (std dev: ${mod_std:,.2f} vs ${orig_std:,.2f})
* Higher volatility means more uncertainty"""

if orig_max > mod_max:
    upside_text = f"""
* The Original strategy has BETTER UPSIDE (max: ${orig_max:,.2f} vs ${mod_max:,.2f})
* Can achieve much higher maximum returns"""

else:
    upside_text = f"""
* The Modified strategy has BETTER UPSIDE (max: ${mod_max:,.2f} vs ${orig_max:,.2f})
* Can achieve much higher maximum returns"""

summary_block = f"""
### **Original vs Modified Strategy (50% at Risk)**

| Strategy | Mean Final Balance | Median Final Balance | Standard Deviation | Minimum | Maximum | P(final > ${starting_balance:,}) | Profitable Simulations |
|----------|-------------------|---------------------|--------------------|---------|---------|--------------------------------|------------------------|
| Original | ${orig_mean:,.2f} | ${orig_median:,.2f} | ${orig_std:,.2f} | ${orig_min:,.2f} | ${orig_max:,.2f} | {orig_prob_gain:.2%} | {np.sum(original_balances > starting_balance)}/{n_simulations} |
| Modified | ${mod_mean:,.2f} | ${mod_median:,.2f} | ${mod_std:,.2f} | ${mod_min:,.2f} | ${mod_max:,.2f} | {mod_prob_gain:.2%} | {np.sum(modified_balances > starting_balance)}/{n_simulations} |

#### Original Strategy (Full Balance at Risk)
* Mean final balance: ${orig_mean:,.2f}
* Median final balance: ${orig_median:,.2f}
* Standard deviation: ${orig_std:,.2f}
* Minimum: ${orig_min:,.2f}
* Maximum: ${orig_max:,.2f}
* P(final > ${starting_balance:,}): {orig_prob_gain:.2%}
* Profitable simulations: {np.sum(original_balances > starting_balance)}/{n_simulations}

#### Modified Strategy (50% of Balance at Risk)
* Mean final balance: ${mod_mean:,.2f}
* Median final balance: ${mod_median:,.2f}
* Standard deviation: ${mod_std:,.2f}
* Minimum: ${mod_min:,.2f}
* Maximum: ${mod_max:,.2f}
* P(final > ${starting_balance:,}): {mod_prob_gain:.2%}
* Profitable simulations: {np.sum(modified_balances > starting_balance)}/{n_simulations}

#### **Comparison**
* Mean difference: ${mod_mean - orig_mean:,.2f}
* Std dev ratio (mod/orig): {mod_std/orig_std:.2f}
* Max difference: ${mod_max - orig_max:,.2f}
* Min difference: ${mod_min - orig_min:,.2f}
* Probability gain diff: {mod_prob_gain - orig_prob_gain:.2%}

#### **Interpretation: Which is Riskier? Which has Better Upside?**
**The Original Strategy (Full Balance at Risk) has:**
{risk_text}
{upside_text}
"""

modified_bullet_block = """
**The Modified Strategy (50% at risk) has:**

* Lower risk per round (only 50% of balance exposed to coin flip)

* More conservative approach (50% always kept safe)

* Lower maximum potential but also lower minimum loss
* Reduced volatility compared to full-risk strategy
"""

display(Markdown(summary_block))
display(Markdown(modified_bullet_block))
```

#### Interpretation of the distributions

```{python}
#| echo: false
#| output: asis

orig_prob_gain_pct = orig_prob_gain * 100
mod_prob_gain_pct = mod_prob_gain * 100

summary = f"""
#### **What the figure shows**
- Full-risk outcomes sprawl from ${orig_min:,.0f} to ${orig_max:,.0f}; the long right tail raises the mean (${orig_mean:,.0f}) well above the median (${orig_median:,.0f}).

- The 50%-at-risk strategy compresses the range (${mod_min:,.0f} to ${mod_max:,.0f}), nudging the mean (${mod_mean:,.0f}) and median (${mod_median:,.0f}) much closer together.

- Only {orig_prob_gain_pct:.1f}% of full-risk simulations finish above ${starting_balance:,}, versus {mod_prob_gain_pct:.1f}% when half the balance is protected each flip.

- The histogram‚Äôs overlapping bars make the trade-off clear: the original game delivers rare but massive wins, while the modified plan clusters in a narrower, more predictable band.

#### **Bottom line**
The chart confirms that cutting risk in half sacrifices extreme upside but dramatically improves the odds of walking away with more than the initial $30,000.
"""

display(Markdown(summary))
```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
#### Kelly Criterion Summary

```{python}
#| label: q6-kelly-criterion
#| echo: false
#| output: asis
#| fig-cap: "Kelly Criterion Diagnostics"

import numpy as np
p = 0.5
gain = 0.5   # +50% on the amount staked
loss = 0.4   # -40% on the amount staked

fractions = np.linspace(0.0, 1.0, 401)
log_growth = p * np.log(1 + gain * fractions) + (1 - p) * np.log(1 - loss * fractions)

kelly_fraction = fractions[np.argmax(log_growth)]
kelly_growth = log_growth.max()

full_risk_growth = p * np.log(1 + gain * 1.0) + (1 - p) * np.log(1 - loss * 1.0)
half_risk_growth = p * np.log(1 + gain * 0.5) + (1 - p) * np.log(1 - loss * 0.5)

kelly_summary = f"""
**Kelly Criterion Diagnostics**

* Kelly-optimal fraction to stake each flip: {kelly_fraction:.1%}
* Expected log-growth at the Kelly fraction: {kelly_growth:.4f} per flip
* Expected log-growth when staking 100% (original game): {full_risk_growth:.4f} per flip
* Expected log-growth when staking 50% (modified strategy): {half_risk_growth:.4f} per flip
"""

print(kelly_summary)
```

The Kelly Criterion is a bankroll-management rule that maximizes long-run wealth by choosing the bet fraction that maximizes expected log returns. In this coin-flip game, the optimal Kelly fraction is about 25.0%, so a Kelly bettor would stake roughly one-third of their bankroll each flip. Risking the entire balance (the original strategy) pushes the log-growth rate negative (-0.0527 per flip), which matches the histogram evidence of many wipeouts. Halving the stake to 50% raises the log-growth rate to 0.0000 per flip, moving closer to the Kelly-optimal path while still allowing meaningful upside. Practitioners often bet below the strict Kelly level to guard against streaks and model error; the modified strategy mirrors that prudence by always sheltering half of the account.


